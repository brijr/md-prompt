{"version":3,"sources":["../src/loader.ts","../src/stringify.ts","../src/extract.ts"],"sourcesContent":["import { readFile } from 'fs/promises';\nimport { pathToFileURL } from 'url';\nimport { mdToString } from './stringify.js';\nimport { extractPlaceholders, generateTemplateFunction } from './extract.js';\n\nexport async function resolve(\n  specifier: string,\n  context: any,\n  defaultResolve: any\n): Promise<any> {\n  if (specifier.endsWith('.md')) {\n    return {\n      url: pathToFileURL(specifier).href,\n      format: 'module',\n    };\n  }\n  \n  return defaultResolve(specifier, context, defaultResolve);\n}\n\nexport async function load(\n  url: string,\n  context: any,\n  defaultLoad: any\n): Promise<any> {\n  if (url.endsWith('.md')) {\n    const filePath = new URL(url).pathname;\n    const content = await readFile(filePath, 'utf-8');\n    const stringified = await mdToString(content);\n    const placeholders = extractPlaceholders(stringified);\n    const jsCode = generateTemplateFunction(stringified, placeholders);\n    \n    return {\n      format: 'module',\n      source: jsCode,\n    };\n  }\n  \n  return defaultLoad(url, context, defaultLoad);\n}","import { remark } from \"remark\";\nimport strip from \"strip-markdown\";\n\nexport interface StringifyOptions {\n  collapse?: boolean;\n  remarkPlugins?: any[];\n}\n\nexport async function mdToString(\n  raw: string,\n  options: StringifyOptions = {}\n): Promise<string> {\n  const {\n    collapse = true,\n    remarkPlugins = [],\n  } = options;\n\n  let processor = remark();\n  \n  for (const plugin of remarkPlugins) {\n    if (plugin) {\n      processor = processor.use(plugin);\n    }\n  }\n  \n  processor = processor.use(strip as any);\n  \n  const file = await processor.process(raw);\n  let result = String(file);\n  \n  if (collapse) {\n    result = result.replace(/\\s+/g, \" \").trim();\n  } else {\n    result = result.trim();\n  }\n  \n  return result;\n}\n\n","export interface PlaceholderInfo {\n  name: string;\n  type?: string;\n  optional: boolean;\n  raw: string;\n}\n\nexport function extractPlaceholders(src: string): PlaceholderInfo[] {\n  const re = /\\{([a-zA-Z0-9_]+?)(\\?)?(?::([a-z]+))?\\}/g;\n  const placeholders: PlaceholderInfo[] = [];\n  const seen = new Set<string>();\n  let match;\n  \n  while ((match = re.exec(src))) {\n    const [raw, name, optionalMarker, type] = match;\n    const key = `${name}${optionalMarker || ''}${type ? `:${type}` : ''}`;\n    \n    if (!seen.has(key) && name) {\n      seen.add(key);\n      const placeholder: PlaceholderInfo = {\n        name,\n        optional: Boolean(optionalMarker),\n        raw,\n      };\n      if (type) {\n        placeholder.type = type;\n      }\n      placeholders.push(placeholder);\n    }\n  }\n  \n  return placeholders;\n}\n\nexport function generateTypeDefinition(placeholders: PlaceholderInfo[]): string {\n  const required: string[] = [];\n  const optional: string[] = [];\n  \n  for (const placeholder of placeholders) {\n    const tsType = mapPlaceholderType(placeholder.type);\n    const prop = `${placeholder.name}: ${tsType}`;\n    \n    if (placeholder.optional) {\n      optional.push(`${placeholder.name}?: ${tsType}`);\n    } else {\n      required.push(prop);\n    }\n  }\n  \n  const allProps = [...required, ...optional];\n  return allProps.length > 0 ? `{ ${allProps.join('; ')} }` : '{}';\n}\n\nfunction mapPlaceholderType(type?: string): string {\n  switch (type) {\n    case 'number':\n      return 'number';\n    case 'boolean':\n      return 'boolean';\n    case 'json':\n      return 'Record<string, unknown>';\n    default:\n      return 'string';\n  }\n}\n\nexport function generateTemplateFunction(\n  content: string,\n  placeholders: PlaceholderInfo[]\n): string {\n  const typeDefinition = generateTypeDefinition(placeholders);\n  const hasPlaceholders = placeholders.length > 0;\n  \n  if (!hasPlaceholders) {\n    return `export default ${JSON.stringify(content)};`;\n  }\n  \n  let templateBody = content;\n  for (const placeholder of placeholders) {\n    const regex = new RegExp(escapeRegExp(placeholder.raw), 'g');\n    templateBody = templateBody.replace(regex, `\\${vars.${placeholder.name}}`);\n  }\n  \n  return `export default function(vars: ${typeDefinition}): string {\n  return \\`${templateBody.replace(/`/g, '\\\\`').replace(/\\$(?!{)/g, '\\\\$')}\\`;\n}`;\n}\n\nfunction escapeRegExp(string: string): string {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n"],"mappings":"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","names":[]}